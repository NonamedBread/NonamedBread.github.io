I"#,<h1 id="14활동activity-다이어그램">14.활동(Activity) 다이어그램</h1>

<ul>
  <li>
    <p>자료 흐릅도(DFD, Data Flow Diagram)와 유사</p>
  </li>
  <li>
    <p>시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한 것</p>
  </li>
  <li>
    <p>유스케이스 안에서 혹은 유스케이스 사이의 복잡한 처리의 흐름을 표현</p>
  </li>
</ul>

<h2 id="활동activity-다이어그램-구성-요소">활동(Activity) 다이어그램 구성 요소</h2>

<table>
  <tr>
    <th>
      구성요소
    </th>
    <th>
      표현 방법
    </th>
    <th>
    내용
    </th>
  </tr>
  <tr>
    <td>
      액션(Action) / 액티비티(Activity)
    </td>
    <td>
     액션
     <image src="https://user-images.githubusercontent.com/93482597/163842008-e7bcb2e6-ed40-41a9-9729-547c839e7f4e.png" />
     액티비티
     <image src="https://user-images.githubusercontent.com/93482597/163842165-f2abf7d7-185b-4d9f-be98-3e12100087c9.png" />
    </td>
    <td>
      액션 : 더 이상 분해할 수 없는 단일 작업<br />액티비티 : 몇 개의 액션으로 분리될 수 있는 작업
    </td>
  </tr>
  <tr>
    <td>
    시작노드
    </td>
    <td>
      <image src="https://user-images.githubusercontent.com/93482597/163842710-a9fe1c28-b987-425d-9c6e-136a68add711.png" />
    </td>
    <td>
      액션이나 액티비티가 시작됨을 표현한 것
    </td>
  </tr>
  <tr>
    <td>
      종료 노드
    </td>
    <td>
      <image src="https://user-images.githubusercontent.com/93482597/163842454-5826ff6e-54f4-45a6-9d59-7288fa5aa603.png" />
    </td>
    <td>
     액티비티 안의 모든 흐름이 종료됨을 표현
    </td>
  </tr>
  <tr>
    <td>
      조건(판단) 노드
    </td>
    <td>
      <image src="https://user-images.githubusercontent.com/93482597/163842939-86d69c88-7c64-45a9-91b9-5fec8a31799f.png" />
    </td>
    <td>
      조건에 따라 제어의 흐름이 분리됨을 표현
    </td>
  </tr>
  <tr>
    <td>
    병합 노드
    </td>
    <td>
      <image src="https://user-images.githubusercontent.com/93482597/163843327-29febc2d-e0d5-4d54-9d42-b908f818746a.png" />
    </td>
    <td>
      여러 경로의 흐름이 하나로 합쳐짐을 표현
    </td>
  </tr>
  <tr>
    <td>
     포크(Fork) 노드
    </td>
    <td>
    <image src="https://user-images.githubusercontent.com/93482597/163843596-04e31644-56f3-4276-a148-a95f6ab0cc54.png" />
    </td>
    <td>
    액티비티의 흐름이 분리되어 수행됨을 표현
    </td>
  </tr>
  <tr>
    <td>
    조인(Join) 노드
    </td>
    <td>
    <image src="https://user-images.githubusercontent.com/93482597/163843736-4de59faf-0dab-4ae7-b5bc-3529399271c1.png" />
    </td>
    <td>
      분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현
    </td>
  </tr>
  <tr>
    <td>
      스윔레인(Swim Lane)
    </td>
    <td>
      <image src="https://user-images.githubusercontent.com/93482597/163846448-bce172e2-f785-436e-8e30-420b954c8a8e.png" />
    </td>
    <td>
     액티비티 수행을 담당하는 주체를 구분하는 선<br />가로 또는 세로 실선을 그어 구분
    </td>
  </tr>
</table>

<h1 id="15-클래스class-다이어그램">15. 클래스(Class) 다이어그램</h1>

<h2 id="클래스-다이어그램">클래스 다이어그램</h2>

<ul>
  <li>시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램</li>
  <li>시스템을 구성하는 요소를 문서화 하는데 사용</li>
  <li>코딩에 필요한 객체의 속성, 함수 등의 정보를 잘 표현하고 있어 시스템을 모델링하는 데자주 사용</li>
  <li>
    <p>클래스, 제약조건, 관계 등으로 구성</p>
  </li>
  <li>클래스 다이어그램은 UML 다이어그램 중 객체(Object)들을 클래스로 추상화하여 표현하는 다이어그램으로 대표적인 구조적 다이어그램이다.</li>
  <li>클래스는 각각의 객체들이 갖는 속성과 메소드를 표현한 것으로 3개의 구획으로 나눠 이름, 속성, 메소드를 표기한다.</li>
</ul>

<h2 id="연관-클래스">연관 클래스</h2>

<ul>
  <li>연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스</li>
  <li>두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 연관클래스로 이어 표시</li>
  <li>연관클래스의 이름은 연관 관계의 이름을 이용해 지정</li>
</ul>

<h1 id="16-시퀀스sequence-다이어그램">16. 시퀀스(Sequence) 다이어그램</h1>

<h2 id="구성-요소">구성 요소</h2>

<ul>
  <li>액터(Actor) : 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미</li>
  <li>객체(Object)  : 메시지를 주고받는 주체</li>
  <li>생명선(Lifeline) : 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현// 객체 소멸이 표시된 기간까지 존재</li>
  <li>실행 상자(Active Box, 활성 상자) : 객체가 메시지를 주고 받으며 구동되고 있음을 표현</li>
  <li>메시지(Message) : 객체가 상호 작용을 위해 주고받는 메시지</li>
  <li>객체 소멸 : 해당 객체가 더이상 메모리에 존재하지 않음을 표현</li>
  <li>프레임(Frame) : 다이어그램의 전체 또는 일부를 묶어 표현</li>
</ul>

<h2 id="특징">특징</h2>

<ul>
  <li>시스텡이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현</li>
</ul>

<h1 id="17-커뮤니케이션communication-다이어그램">17. 커뮤니케이션(Communication) 다이어그램</h1>

<h2 id="특징-1">특징</h2>

<ul>
  <li>시스템이나 객체들이 메시지를 주고 받으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객체, 링크, 메시지 등의 요소를 사용하여 그림으로 표현</li>
  <li>동작에 참여하는 객체들 사이의 간계를 파악하는데 사용</li>
</ul>

<h2 id="구성-요소-1">구성 요소</h2>
<ul>
  <li>액터(ACtor) : 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미</li>
  <li>객체(Object) : 메시지를 주고받는 주체</li>
  <li>링크(Link) : 객체들 간의 관계를 표현한 것 // 액터와 객체, 객체와 객체 간에 실선을 그어 표현</li>
  <li>메시지(Message) : 객체가 상호 작용을 위해 주고받는 내용 //  화살표의 방향은 메시지를 받는 쪽으로 향하게 표현 // 일정한 순서에 의해 처리되는 메시지의 경우 숫자로 순서를 표시</li>
</ul>

<h1 id="18-상태state-다이어그램">18. 상태(State) 다이어그램</h1>

<h2 id="특징-2">특징</h2>
<ul>
  <li>객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현</li>
  <li>객체의 상태란 객체가 갖는 속성 값의 변화를 의미</li>
  <li>특정 객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인</li>
</ul>

<h1 id="19-패키지package-다이어그램">19. 패키지(Package) 다이어그램</h1>

<h2 id="특징-3">특징</h2>
<ul>
  <li>요소들을 그룹화한 패키지간의 의존 관계를 표현</li>
  <li>패키지는 또 다른 패키지의 요소가 될 수 있다.</li>
  <li>대규모 시스템에서 주요 요소 간의 종속성을 파악하는데 사용</li>
</ul>

<h1 id="20-소프트웨어-개발-방법론">20 소프트웨어 개발 방법론</h1>

<h2 id="컴포넌트-기반cbd-component-based-design-방법론">컴포넌트 기반(CBD; Component Based Design) 방법론</h2>

<ul>
  <li>
    <p>기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론</p>
  </li>
  <li>
    <p>특징</p>
    <ul>
      <li>개발 기간 단축으로 인한 생산성 향상</li>
      <li>새로운 기능 추가가 쉬운 확장성</li>
      <li>소프트웨어 재사용이 가능</li>
    </ul>
  </li>
</ul>

<h2 id="구조적-방법론">구조적 방법론</h2>

<ul>
  <li>
    <p>사용자 요구사항을 파악하요 문서화하는 처리(Process) 중심의 방법론</p>
  </li>
  <li>
    <p>구조적 방법론의 개발 절차</p>
    <ul>
      <li>타당성 검토 단계 -&gt; 계획 단계 -&gt; 요구사항 단계 -&gt; 설계 단계 -&gt; 구현 단계 -&gt; 시험 단계 -&gt; 운용/유지보수 단계</li>
    </ul>
  </li>
</ul>

<h2 id="정보공학-방법론">정보공학 방법론</h2>

<ul>
  <li>
    <p>계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료(Data) 중심의 방법론</p>
  </li>
  <li>
    <p>개발절차</p>
    <ul>
      <li>정보 전략 계획 수립 단계 -&gt; 업무 영역 분석 단계 -&gt; 업무 시스템 설계 단계 -&gt; 업무 시스템 구축 단계</li>
    </ul>
  </li>
</ul>

<h2 id="객체-지향-방법론">객체 지향 방법론</h2>

<ul>
  <li>
    <p>객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론</p>
  </li>
  <li>
    <p>개발 절차</p>
    <ul>
      <li>요구 분석 단계 -&gt; 설계 단계 -&gt; 구현 단계 -&gt; 테스트 및 검증 단계 -&gt; 인도 단계</li>
    </ul>
  </li>
</ul>

<h1 id="21-sw-공학의-발전적-추세">21. S/W 공학의 발전적 추세</h1>

<h2 id="소프트웨어-재사용software-reuse">소프트웨어 재사용(Software Reuse)</h2>
<ul>
  <li>이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용</li>
</ul>

<h3 id="소프트웨어-재사용-방법">소프트웨어 재사용 방법</h3>

<ul>
  <li>
    <p>합성 중심(Composition-Based) : 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법, 블록 구성 방법이라고도 함</p>
  </li>
  <li>
    <p>생성 중심(Generation-Based) : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 함</p>
  </li>
</ul>

<h2 id="소프트웨어-재공학software-reengineering">소프트웨어 재공학(Software Reengineering)</h2>
<ul>
  <li>기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상 시키는 것</li>
</ul>

<h3 id="이점">이점</h3>
<ul>
  <li>소프트웨어의 품질 향상</li>
  <li>생산성 증가</li>
  <li>수명 연장</li>
  <li>오류 감소</li>
</ul>

<h2 id="casecomputer-aided-software-engineering">CASE(Computer Aided Software Engineering)</h2>

<ul>
  <li>소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화 하는 것</li>
</ul>

<h3 id="주요-기능">주요 기능</h3>
<ul>
  <li>소프트웨어 생명 주기 전 단계의 연결</li>
  <li>다양한 소프트웨어 개발 모형 지원</li>
  <li>그래픽 지원</li>
</ul>

:ET